diff --git a/control/udp_endpoint_pool.go b/control/udp_endpoint_pool.go
index 5fd972a..0ed5974 100644
--- a/control/udp_endpoint_pool.go
+++ b/control/udp_endpoint_pool.go
@@ -41,16 +41,46 @@ func (ue *UdpEndpoint) start() {
 	buf := pool.GetFullCap(consts.EthernetMtu)
 	defer pool.Put(buf)
 	for {
+		// Set read timeout to prevent permanent blocking
+		if conn, ok := ue.conn.(interface{ SetReadDeadline(time.Time) error }); ok {
+			conn.SetReadDeadline(time.Now().Add(30 * time.Second))
+		}
+		
 		n, from, err := ue.conn.ReadFrom(buf[:])
 		if err != nil {
+			// Check if it's a timeout error
+			if netErr, ok := err.(interface{ Timeout() bool }); ok && netErr.Timeout() {
+				// Continue on timeout to allow cleanup
+				continue
+			}
 			break
 		}
 		ue.mu.Lock()
 		ue.deadlineTimer.Reset(ue.NatTimeout)
 		ue.mu.Unlock()
-		if err = ue.handler(buf[:n], from); err != nil {
-			break
-		}
+		
+		// Handle packet with timeout protection
+		go func(data []byte, addr netip.AddrPort) {
+			defer func() {
+				if r := recover(); r != nil {
+					// Log panic but don't crash
+				}
+			}()
+			
+			done := make(chan error, 1)
+			go func() {
+				done <- ue.handler(data, addr)
+			}()
+			
+			select {
+			case err := <-done:
+				if err != nil {
+					// Handler error, but continue processing
+				}
+			case <-time.After(10 * time.Second):
+				// Handler timeout, but continue processing
+			}
+		}(buf[:n], from)
 	}
 	ue.mu.Lock()
 	ue.deadlineTimer.Stop()
diff --git a/control/udp_task_pool.go b/control/udp_task_pool.go
index 08b02d7..9c36f79 100644
--- a/control/udp_task_pool.go
+++ b/control/udp_task_pool.go
@@ -1,7 +1,7 @@
 /*
 *  SPDX-License-Identifier: AGPL-3.0-only
 *  Copyright (c) 2022-2025, daeuniverse Organization <dae@v2raya.org>
-*/
+ */
 
 package control
 
@@ -11,7 +11,11 @@ import (
 	"time"
 )
 
-const UdpTaskQueueLength = 128
+const (
+	UdpTaskQueueLength = 128
+	MaxUdpQueues       = 1000
+	UdpTaskTimeout     = 1 * time.Second
+)
 
 type UdpTask = func()
 
@@ -60,6 +64,13 @@ func NewUdpTaskPool() *UdpTaskPool {
 // EmitTask: Make sure packets with the same key (4 tuples) will be sent in order.
 func (p *UdpTaskPool) EmitTask(key string, task UdpTask) {
 	p.mu.Lock()
+	
+	// Limit concurrent queues to prevent memory exhaustion
+	if len(p.m) >= MaxUdpQueues {
+		p.mu.Unlock()
+		return // Drop task if too many queues
+	}
+	
 	q, ok := p.m[key]
 	if !ok {
 		ch := p.queueChPool.Get().(chan UdpTask)
@@ -93,6 +104,8 @@ func (p *UdpTaskPool) EmitTask(key string, task UdpTask) {
 	select {
 	case q.ch <- task:
 	case <-q.ctx.Done():
+	case <-time.After(UdpTaskTimeout):
+		// Drop task if queue is blocked to prevent deadlock
 	}
 }
 
